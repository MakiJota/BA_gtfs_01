let comunas, stops, routes, shapes, trips, stopTimes;
let lonMin, lonMax, latMin, latMax;
let subteColors; 
let titleText;

// ================== CONFIG ==================
let city = "BA"; // <-- change to "NYC" to switch

const cityConfigs = {
  "BA": {
    folder: "assets/BA/",
    lonMin: -58.55, lonMax: -58.35,
    latMin: -34.7, latMax: -34.55,
    title: "Buenos Aires Subte Map",
    colors: {
      'A': '#00AEEF',
      'B': '#DA291C',
      'C': '#003DA5',
      'D': '#009739',
      'E': '#702082',
      'H': '#FFD100'
    }
  },
  "NYC": {
    folder: "assets/NYC/",
    lonMin: -74.05, lonMax: -73.75,
    latMin: 40.63,  latMax: 40.85,
    title: "New York City Subway Map",
    colors: {
      '1': '#EE352E','2': '#EE352E','3': '#EE352E',
      '4': '#00933C','5': '#00933C','6': '#00933C',
      '7': '#B933AD',
      'A': '#2850AD','C': '#2850AD','E': '#2850AD',
      'B': '#FF6319','D': '#FF6319','F': '#FF6319','M': '#FF6319',
      'G': '#6CBE45',
      'J': '#996633','Z': '#996633',
      'L': '#A7A9AC',
      'N': '#FCCC0A','Q': '#FCCC0A','R': '#FCCC0A','W': '#FCCC0A',
      'S': '#808183'
    }
  }
};

// Active config
let cfg = cityConfigs[city];

// zoom/pan vars
let zoom = 1;
let offsetX = 0, offsetY = 0;
let dragging = false;
let lastX, lastY;

// store comuna fill colors
let comunaColors = [];

// ========== VAGONS ==========
let shapePaths = {};  // shape_id â†’ array of {x, y, seq, dist}
let vagons = [];      // {shape_id, dist, speed, color, totalDist}

function preload() {
  city_limit = loadJSON(cfg.folder + 'limit.geojson');
  stops     = loadTable(cfg.folder + 'GTFS/stops.txt', 'csv', 'header');
  routes    = loadTable(cfg.folder + 'GTFS/routes.txt', 'csv', 'header');
  shapes    = loadTable(cfg.folder + 'GTFS/shapes.txt', 'csv', 'header');
  trips     = loadTable(cfg.folder + 'GTFS/trips.txt', 'csv', 'header');
  stopTimes = loadTable(cfg.folder + 'GTFS/stop_times.txt', 'csv', 'header');
}

function setup() {
  createCanvas(1200, 1200);
  console.log("Setup complete for " + city);

  lonMin = cfg.lonMin;
  lonMax = cfg.lonMax;
  latMin = cfg.latMin;
  latMax = cfg.latMax;
  subteColors = cfg.colors;
  titleText = cfg.title;

  if (city_limit) {
    for (let i = 0; i < city_limit.features.length; i++) {
      comunaColors[i] = color(random(180, 230), 200);
    }
  }

  prepareShapePaths();
  setupVagons();
}

// ========== DRAW LOOP ==========
function draw() {
  background(240);

  // Draw title
  noStroke();
  fill(0);
  textSize(24);
  textAlign(LEFT, TOP);
  text(titleText, 10, 10);

  // Clock under title
  let h = hour();
  let m = minute();
  let clockText = nf(h, 2) + ":" + nf(m, 2);
  textSize(18);
  text(clockText, 10, 40);

  // Apply zoom/pan
  translate(width/2 + offsetX, height/2 + offsetY);
  scale(zoom);
  translate(-width/2, -height/2);

  drawComunas();
  drawSubteRoutes();
  drawStops();
  drawVagons();
}

// ========== DRAWING FUNCTIONS ==========
function drawComunas() {
  if (!city_limit) return;

  noStroke();
  for (let f = 0; f < city_limit.features.length; f++) {
    let feature = city_limit.features[f];
    let geom = feature.geometry;
    fill(comunaColors[f]);

    if (!geom) continue;

    if (geom.type === "Polygon") {
      drawPolygon(geom.coordinates);
    } else if (geom.type === "MultiPolygon") {
      for (let p = 0; p < geom.coordinates.length; p++) {
        drawPolygon(geom.coordinates[p]);
      }
    }
  }
}

function drawPolygon(coords) {
  for (let r = 0; r < coords.length; r++) {
    beginShape();
    for (let i = 0; i < coords[r].length; i++) {
      let lon = coords[r][i][0];
      let lat = coords[r][i][1];

      let x = map(lon, lonMin, lonMax, 50, width - 50);
      let y = map(lat, latMin, latMax, height - 50, 50);

      vertex(x, y);
    }
    endShape(CLOSE);
  }
}

function drawSubteRoutes() {
  if (!shapes) return;

  strokeWeight(3);

  let shapesById = {};
  for (let r = 0; r < shapes.getRowCount(); r++) {
    let shape_id = shapes.getString(r, 'shape_id');
    let lat = float(shapes.getString(r, 'shape_pt_lat'));
    let lon = float(shapes.getString(r, 'shape_pt_lon'));
    let seq = int(shapes.getString(r, 'shape_pt_sequence'));

    if (!shapesById[shape_id]) shapesById[shape_id] = [];
    shapesById[shape_id].push({lat, lon, seq});
  }

  for (let shape_id in shapesById) {
    let pts = shapesById[shape_id];
    pts.sort((a,b) => a.seq - b.seq);

    let lineLetter = shape_id.charAt(0); 
    stroke(subteColors[lineLetter] || 'black');
    noFill();

    beginShape();
    for (let pt of pts) {
      let x = map(pt.lon, lonMin, lonMax, 50, width - 50);
      let y = map(pt.lat, latMin, latMax, height - 50, 50);
      vertex(x, y);
    }
    endShape();
  }
}

// draw all stops
function drawStops() {
  if (!stops || !routes || !trips || !stopTimes) return;

  let routeToLine = {};
  for (let r = 0; r < routes.getRowCount(); r++) {
    let route_id = routes.getString(r, 'route_id');
    let route_short_name = routes.getString(r, 'route_short_name'); 
    routeToLine[route_id] = route_short_name;
  }

  let tripToRoute = {};
  for (let r = 0; r < trips.getRowCount(); r++) {
    tripToRoute[trips.getString(r, 'trip_id')] = trips.getString(r, 'route_id');
  }

  let stopToRoute = {};
  for (let r = 0; r < stopTimes.getRowCount(); r++) {
    let stop_id = stopTimes.getString(r, 'stop_id');
    let trip_id = stopTimes.getString(r, 'trip_id');
    let route_id = tripToRoute[trip_id];
    if (route_id) {
      if (!stopToRoute[stop_id]) stopToRoute[stop_id] = route_id;
    }
  }

  stroke(0);
  strokeWeight(1);
  for (let r = 0; r < stops.getRowCount(); r++) {
    let stop_id = stops.getString(r, 'stop_id');
    let lat = float(stops.getString(r, 'stop_lat'));
    let lon = float(stops.getString(r, 'stop_lon'));
    if (isNaN(lat) || isNaN(lon)) continue;

    let route_id = stopToRoute[stop_id];
    let lineLetter = route_id ? routeToLine[route_id] : null;
    if (!lineLetter || !subteColors[lineLetter]) continue;

    fill(subteColors[lineLetter]);
    let x = map(lon, lonMin, lonMax, 50, width - 50);
    let y = map(lat, latMin, latMax, height - 50, 50);

    stroke(0);
    strokeWeight(0.5);
    ellipse(x, y, 5, 5);
  }
}

// ========== VAGONS ==========
function prepareShapePaths() {
  if (!shapes) return;
  for (let r = 0; r < shapes.getRowCount(); r++) {
    let shape_id = shapes.getString(r, 'shape_id');
    let lat = float(shapes.getString(r, 'shape_pt_lat'));
    let lon = float(shapes.getString(r, 'shape_pt_lon'));
    let seq = int(shapes.getString(r, 'shape_pt_sequence'));

    if (!shapePaths[shape_id]) shapePaths[shape_id] = [];
    let x = map(lon, lonMin, lonMax, 50, width - 50);
    let y = map(lat, latMin, latMax, height - 50, 50);
    shapePaths[shape_id].push({x, y, seq});
  }

  for (let sid in shapePaths) {
    let pts = shapePaths[sid];
    pts.sort((a,b) => a.seq - b.seq);

    // compute cumulative distance
    let dist = 0;
    pts[0].dist = 0;
    for (let i=1; i<pts.length; i++) {
      let dx = pts[i].x - pts[i-1].x;
      let dy = pts[i].y - pts[i-1].y;
      dist += sqrt(dx*dx + dy*dy);
      pts[i].dist = dist;
    }
    shapePaths[sid].totalDist = dist;
  }
}

function setupVagons() {
  for (let shape_id in shapePaths) {
    for (let i = 0; i < 3; i++) {
      let lineLetter = shape_id.charAt(0);
      let col = subteColors[lineLetter] || color(random(50, 255), random(50, 255), random(50, 255));
      vagons.push({
        shape_id: shape_id,
        dist: random(shapePaths[shape_id].totalDist),
        speed: random(2, 6), // pixels per frame
        color: col,
        totalDist: shapePaths[shape_id].totalDist
      });
    }
  }
}

function drawVagons() {
  strokeWeight(1);
  for (let v of vagons) {
    let pts = shapePaths[v.shape_id];
    if (!pts || pts.length < 2) continue;

    v.dist += v.speed;
    if (v.dist > v.totalDist) v.dist = 0;

    let p1, p2;
    for (let i=1; i<pts.length; i++) {
      if (v.dist <= pts[i].dist) {
        p1 = pts[i-1];
        p2 = pts[i];
        break;
      }
    }
    if (!p1 || !p2) continue;

    let segLen = p2.dist - p1.dist;
    let t = (v.dist - p1.dist) / segLen;

    let x = lerp(p1.x, p2.x, t);
    let y = lerp(p1.y, p2.y, t);

    fill(v.color);
    stroke(0);
    ellipse(x, y, 10, 10);
  }
}

// ========== INTERACTIVITY ==========
function mouseWheel(event) {
  zoom *= (event.delta > 0) ? 0.9 : 1.1;
  return false;
}

function mousePressed() {
  dragging = true;
  lastX = mouseX;
  lastY = mouseY;
}

function mouseReleased() {
  dragging = false;
}

function mouseDragged() {
  if (dragging) {
    offsetX += (mouseX - lastX);
    offsetY += (mouseY - lastY);
    lastX = mouseX;
    lastY = mouseY;
  }
}
